import { Assert } from 'caribviper-common';
import { ENTITY_MODELS } from './../../entity-model-type';
import { UserInfo } from './../../../value-objects/common/userinfo';
import { DateRecord } from './../../../value-objects/common/date-record';
import { IRegistryDetails, RegistryDetails } from './../iregistry-details';

/**
 * Specifies the enforcement notice done
 */
export class Notice {

  public dates: DateRecord;

  /**Id of the linked document */
  public documentId: string;

  constructor(public type: string, public content: string, user: UserInfo) {
    this.dates = new DateRecord(user);
  }

  /**
   * Signs a notice with the specified user
   * @param user User signing the notice
   */
  sign(user: UserInfo) { this.dates.sign(user); }

  /**
   * Dispatches a notice by the specifed user
   * @param user User dispatching the notice
   */
  dispatch(user: UserInfo) { this.dates.dispatch(user); }

}

/**
 * Encapsulates the features for enforcement matters
 */
export class EnforcementFile extends RegistryDetails {

  /**Notices generated by system */
  notices: Notice[];

  /**
   * Creates new Enforcement File details
   * @param registryId linked registry id
   */
  constructor(registryId: string = '') {
    super(ENTITY_MODELS.REGISTRY_DETAILS.ENFORCEMENT.ENFORCEMENT_FILE, EnforcementFile.createId(registryId), true);
    this.registryId = registryId;
    this.notices = [];
  }

  public validateEntity() {
    Assert.isFalse(this.isTransient, 'EnforcementFile cannot be transient');
    Assert.isTruthy(this.registryId, 'EnforcementFile registryId cannot be undefined/empty');
    Assert.isTruthy(this.notices, 'EnforcementFile notices cannot be undefined');
  }

  public static createId(registryId: string): string {
    return this.idHelper(registryId, ENTITY_MODELS.REGISTRY_DETAILS.ENFORCEMENT.ENFORCEMENT_FILE);
  }
}
